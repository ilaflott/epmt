#!/usr/bin/env python3

from sys import exit, stdout, stderr
if (__name__ == "__main__"):
    try:
        import epmt_settings as settings
    except Exception as e:
        print('\n'+str(e)+'\n', file=stderr)
        exit(1)

    from sys import version_info, argv
    from epmt_cmds import epmt_entrypoint, dump_config
    import argparse
    from io import StringIO
    config_string_file = StringIO()

    # Display help when errors occur without dump_config
    class DefaultHelpParser(argparse.ArgumentParser):
        def error(self, message):
            stderr.write('error: %s\n' % message)
            self.epilog=''
            self.print_help()
            exit(2)
    
    # Generate config variable for epilog on long help
    dump_config(config_string_file)
    parser = DefaultHelpParser(prog='epmt', add_help=True, epilog=config_string_file.getvalue(), description=
        "This is a tool to collect metadata and performance data about an entire job"+
        "\ndown to the individual threads in individual processes."+
        "\nThis tool uses EPMT to perform the process monitoring."+
        "\nThis tool is targeted at batch or ephemeral jobs, not daemon processes.",
        formatter_class=argparse.RawDescriptionHelpFormatter)
    
    # Version
    from epmtlib import version_str
    parser.add_argument('-V', '--version',action='version', version=version_str(), help="Display EPMT Version")
    
    # Global Verbose
    parser.add_argument('-v', '--verbose',action='count',help="Increase level of verbosity/debug")

    subparser = parser.add_subparsers(title="EPMT Commands", dest="command")
    # Source
    source_parser = subparser.add_parser('source', help="Environment variables for performance monitoring",
        description="Source provides commands to begin epmt performance monitoring or instrumentation. \
            Instrumentation is automatically called when eval on source is done. Two functions are created \
                for starting of instrumentation epmt_instrument and stopping of instrumentation epmt_uninstrument")
    source_parser.add_argument('-s','--slurm', action='store_true',help="Generate shell code for a SLURM prolog, https://slurm.schedmd.com/prolog_epilog.html")
    source_parser._action_groups.pop()
    # Start
    start_parser = subparser.add_parser('start', help="Begin EPMT logging",
        description="Start will create a metadata log file with the current environment variables.")
    start_parser.add_argument('epmt_cmd_args', nargs='*', help="List of directories from batch")
    # Stage
    stage_parser = subparser.add_parser('stage', help="Generate job archive",
        description="Stage will compress job or job directories into tgz files for midterm storage then remove \
            original job files and job directory.")
    stage_parser.add_argument('epmt_cmd_args', nargs='*', help="List of directories from batch")
    stage_parser.add_argument('-e', '--error', action='store_true',help="Exit at the first sign of trouble")

    # Dump
    dump_parser = subparser.add_parser('dump', help="Print metadata from archive",
        description="Dump will print to console the metadata of a job directory")
    dump_parser.add_argument('epmt_cmd_args', default=[], nargs='*', help="Archive or list of archives to dump")
    # Run
    run_parser = subparser.add_parser('run', help="Execute a process",
        description="Run will execute a command in shell typically used with the auto -a flag to begin instrumentation\
            before the processes is started and stop instrumentation upon completion of the process.")
    run_parser.add_argument('-a', '--auto',action='store_true',help="Do start/stop when running")
    run_parser.add_argument('-n', '--dry-run', action='store_true',help="Don't touch the database")
    run_parser.add_argument('epmt_cmd_args', default=[], nargs='*', help="")
    run_parser.set_defaults(dry_run=False, wrapit=False)
    # Stop
    stop_parser = subparser.add_parser('stop', help="Stop EPMT logging",
        description = "Stop will append to the metadata log file with the environment variables at stop time.")
    stop_parser.set_defaults(epmt_cmd_args=None)
    # Daemon
    daemon_parser = subparser.add_parser('daemon', help="Run the EPMT daemon",
        description = "daemon runs an EPMT daemon that will periodically check and process jobs")
    daemon_parser.add_argument('-s', '--start',action='store_true',help="Start the EPMT daemon")
    daemon_parser.add_argument('-S', '--stop',action='store_true',help="Stop the EPMT daemon")
    daemon_parser.add_argument('-D', '--foreground',action='store_true',help="Start the daemon in foreground")
    daemon_parser.set_defaults(start_daemon=False, stop_daemon=False, foreground=False)
    # shell
    shell_parser = subparser.add_parser('shell', help = "Run an interactive Python shell",
       description = "shell runs an interactive python shell")
    # unittest
    unit_test_parser = subparser.add_parser('unittest', help="Run EPMT unit test suite",
        description = "runs unit tests")
    # drop
    drop_parser = subparser.add_parser('drop', help="Drop the entire database. Caution!! This action is irreversible.")
    drop_parser.add_argument('-f', '--force', action='store_true',help="Do not prompt to confirm")
    # Submit
    submit_parser = subparser.add_parser('submit', help="Commit completed job to database",
        description="Submit accepts job directories and updates the database configured with \
            directories given.  When run with -n submit will not touch the database and displays the commands leading \
                up to submission.")
    submit_parser.add_argument('epmt_cmd_args', nargs='*', help="List of directories")
    submit_parser.add_argument('-e', '--error', action='store_true',help="Exit at the first sign of trouble")
    submit_parser.add_argument('-n', '--dry-run', action='store_true',help="Don't touch the database")
    submit_parser.add_argument('--drop',action='store_true',help="Drop all tables/data and recreate before importing")
    # DBSize
    dbsize_parser = subparser.add_parser('dbsize', help="Find detailed size of database",
        description="dbsize will print to console the physical on disk size of different aspects of the database.\
            dbsize table will give total counts of each table and disk size.  Using the --bytes flag explicitly shows\
                all units for database sizing in bytes only.  The --json flag will print the json output along with basic\
                    metadata about the current configuration")
    dbsize_parser.add_argument('size_of', default=[], nargs='*', help="database, table, index, tablespace")
    dbsize_parser.add_argument('--bytes',action='store_true',help="Returns dbsize in bytes")
    dbsize_parser.add_argument('--json',action='store_true',help="Output JSON results of dbsizes")
    # Check
    check_parser = subparser.add_parser('check', help='Verify EPMT Installation',
        description="Check will verify basic epmt configuration and functionality.")
    # Delete
    delete_parser = subparser.add_parser('delete', help='Delete jobs from the database',
        description="Deletes jobs from the database.")
    delete_parser.add_argument('epmt_cmd_args', nargs='*', help="List of jobs to delete")
    # List
    list_parser = subparser.add_parser('list', help='Display all jobs in the database',
        description="Display all jobs in the database")
    list_parser.add_argument('epmt_cmd_args', nargs='*', help="A list of jobs to search for")
    # Notebook
    notebook_parser = subparser.add_parser('notebook', help="Start iPython Notebook environment",
                                           description="Perform programmatic, interactive analyses of EPMT data in iPython")
    notebook_parser.add_argument('epmt_cmd_args', nargs='*',
                                 help="Arguments to ipython notebook, first one **must** be preceded with double dash followed by a space, i.e. epmt notebook -- --ip 0.0.0.0 --allow-root, see epmt notebook -- --help for more info")

# Dummy Help for ./epmt help
    help_parser = subparser.add_parser('help', help="Display this help with extended configuration information")

    # Print help without dump config
    if len(argv) == 1:
        parser.epilog=''
        parser.print_help()
        exit(1)
    args = parser.parse_args()
    #print(vars(args))

    # Print help if epmt help is called
    if args.command == 'help':
        parser.print_help()
        exit(0)

    # Print help if 
    if args.command == None:
        parser.print_help()
        exit(0)

    # trap any unhandled exceptions
    try:
        retval = epmt_entrypoint(args)
    except Exception as e:
        retval = -1
        print('\n'+str(e)+'\n', file=stderr)
    exit(retval)

else:
    print("ERROR: This module cannot be imported.",file=stderr)
    exit(1)
