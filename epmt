#!/usr/bin/env python3

from sys import exit, stdout, stderr
if (__name__ == "__main__"):
    try:
        import epmt_settings as settings
    except Exception as e:
        print('\n'+str(e)+'\n', file=stderr)
        exit(1)

    from sys import version_info, argv
    from epmt_cmds import epmt_entrypoint, dump_config
    import argparse
    from io import StringIO
    config_string_file = StringIO()

    # Display help when errors occur without dump_config
    class DefaultHelpParser(argparse.ArgumentParser):
        def error(self, message):
            stderr.write('error: %s\n' % message)
            self.epilog=''
            self.print_help()
            exit(2)
    
    # Generate config variable for epilog on long help
    dump_config(config_string_file)
    parser = DefaultHelpParser(prog='epmt', add_help=True, epilog=config_string_file.getvalue(), description=
        "This is a tool to collect metadata and performance data about an entire job"+
        "\ndown to the individual threads in individual processes."+
        "\nThis tool uses EPMT to perform the process monitoring."+
        "\nThis tool is targeted at batch or ephemeral jobs, not daemon processes.",
        formatter_class=argparse.RawDescriptionHelpFormatter)
    
    # Version
    from epmtlib import version_str
    parser.add_argument('-V', '--version',action='version', version=version_str(), help="Display EPMT Version")
    
    # Global Verbose
    parser.add_argument('-v', '--verbose',action='count', default=0,help="Increase level of verbosity/debug")

    subparser = parser.add_subparsers(title="EPMT Commands", dest="command")
    # Source
    source_parser = subparser.add_parser('source', help="Environment variables for performance monitoring",
        description="Source provides commands to begin epmt performance monitoring or instrumentation. \
            Instrumentation is automatically called when eval on source is done. Two functions are created \
                for starting of instrumentation epmt_instrument and stopping of instrumentation epmt_uninstrument")
    source_parser.add_argument('-s','--slurm', action='store_true',help="Generate shell code for a SLURM prolog, https://slurm.schedmd.com/prolog_epilog.html")
    source_parser._action_groups.pop()
    # Start
    start_parser = subparser.add_parser('start', help="Begin EPMT logging",
        description="Start will create a metadata log file with the current environment variables.")
    start_parser.add_argument('epmt_cmd_args', nargs='*', help="List of directories from batch")
    # Stage
    stage_parser = subparser.add_parser('stage', help="Generate job archive",
        description="Stage will compress job or job directories into tgz files for midterm storage then remove \
            original job files and job directory.")
    stage_parser.add_argument('epmt_cmd_args', nargs='*', help="List of directories from batch")
    stage_parser.add_argument('-e', '--error', action='store_true',help="Exit at the first sign of trouble")
    # annotate
    annotate_parser = subparser.add_parser('annotate', help="Annotate a job", formatter_class=argparse.RawTextHelpFormatter, description="Annotates a job with key/value pairs. This call takes three forms:\n\n"
      "To annotate a stopped job within the batch environment: \n"
      "\tepmt annotate x=100 y=200\n\n"
      "To annotate a stage .tgz file:\n"
      "\tepmt annotate 111.tgz x=100 y=200\n\n"
      "To annotate an existing job in the database:\n"
      "\tepmt annotate 685000 x=100 y=200\n\n"
      "In all the above cases the annotations are *merged* on to the existing annotations, unless --replace is set (in which case existing annotations are removed first)")
    annotate_parser.add_argument('epmt_cmd_args', nargs='+', help="key/value pairs in the form key1=value1 key2=value2..")
    annotate_parser.add_argument('--replace',action='store_true',default=False,help="Replace existing annotations instead of merging onto them")

    # show functionality is now handled by dump
    # show_parser = subparser.add_parser('show', help="Show details of job from the database",
    #     description="Show will print to console details of a job from the database")
    # show_parser.add_argument('epmt_cmd_args', help="Job ID in database")
    # show_parser.add_argument('-k', '--key', help="Only show the value for the specified key")

    # Dump
    dump_parser = subparser.add_parser('dump', help="Print job metadata from archive or database",
        description="Dump will print to console the metadata of a job directory, job archive or a job in the database")
    dump_parser.add_argument('epmt_cmd_args', default=[], nargs='*', help="Archive or list of archives to dump from file-system, or a list of jobids from database")
    dump_parser.add_argument('-k', '--key', help="Only dump the value for the specified key")

    # db schema
    db_schema_parser = subparser.add_parser('schema', help="Dump the database schema",
        description="schema will dump the database schema")

    # Run
    run_parser = subparser.add_parser('run', help="Execute a process",
        description="Run will execute a command in shell typically used with the auto -a flag to begin instrumentation\
            before the processes is started and stop instrumentation upon completion of the process.")
    run_parser.add_argument('-a', '--auto',action='store_true',help="Do start/stop when running")
    run_parser.add_argument('-n', '--dry-run', action='store_true',help="Don't touch the database")
    run_parser.add_argument('epmt_cmd_args', default=[], nargs='*', help="")
    run_parser.set_defaults(dry_run=False, wrapit=False)
    # Stop
    stop_parser = subparser.add_parser('stop', help="Stop EPMT logging",
        description = "Stop will append to the metadata log file with the environment variables at stop time.")
    stop_parser.set_defaults(epmt_cmd_args=None)
    # Daemon
    daemon_parser = subparser.add_parser('daemon', help="Run the EPMT daemon",
        description = "daemon runs an EPMT daemon that will periodically check and process jobs")
    daemon_parser.add_argument('-s', '--start',action='store_true',help="Start the EPMT daemon")
    daemon_parser.add_argument('-S', '--stop',action='store_true',help="Stop the EPMT daemon")
    daemon_parser.add_argument('-D', '--foreground',action='store_true',help="Start the daemon in foreground")
    daemon_parser.set_defaults(start_daemon=False, stop_daemon=False, foreground=False)
    # shell
    shell_parser = subparser.add_parser('shell', help = "Run an interactive Python shell",
       description = "shell runs an interactive python shell")
    # python
    py_parser = subparser.add_parser('python', help = "Run a Python script under the python interpreter",
       description = "python runs an executable python script under the python interpreter. If no script is provided as an argument, an interactive python shell is executed")
    py_parser.add_argument('epmt_cmd_args', nargs='?', help="python script to execute")
    # ui
    gui_parser = subparser.add_parser('gui', help = "Run the EPMT dashboard GUI",
       description = "gui a web-based dashboard accessible at: http://localhost:8050")
    # unittest
    unit_test_parser = subparser.add_parser('unittest', help="Run EPMT unit test suite",
        description = "runs unit tests")
    # drop
    drop_parser = subparser.add_parser('drop', help="Drop the entire database. Caution!! This action is irreversible.")
    drop_parser.add_argument('-f', '--force', action='store_true',help="Do not prompt to confirm")
    # retire
    retire_parser = subparser.add_parser('retire', help="Delete jobs and models (based on the data retention policy in settings.py)")
    # Submit
    submit_parser = subparser.add_parser('submit', help="Commit completed job to database",
        description="Submit accepts job directories and updates the database configured with \
            directories given.  When run with -n submit will not touch the database and displays the commands leading \
                up to submission.")
    submit_parser.add_argument('epmt_cmd_args', nargs='*', help="List of directories")
    submit_parser.add_argument('-e', '--error', action='store_true',help="Exit at the first sign of trouble")
    submit_parser.add_argument('-n', '--dry-run', action='store_true',help="Don't touch the database")
    submit_parser.add_argument('--drop',action='store_true',help="Drop all tables/data and recreate before importing")
    from epmtlib import suggested_cpu_count_for_submit
    optimal_cpus = suggested_cpu_count_for_submit()
    submit_parser.add_argument('-p', '--num-cpus', type=int, nargs='?', default=1, const=optimal_cpus, help='Number of parallel processes to use for submission. You should specify no more than the number of available processors on your machine. If this option is selected, but no value is specified, then the optimal value ({0}) will be used, based on your hardware resources. Note: This option is only supported for SQLAlchemy ORM at present.'.format(optimal_cpus))

    # DBSize
    dbsize_parser = subparser.add_parser('dbsize', help="Find detailed size of database",
        description="dbsize will print to console the physical on disk size of different aspects of the database.\
            dbsize table will give total counts of each table and disk size.  Using the --bytes flag explicitly shows\
                all units for database sizing in bytes only.  The --json flag will print the json output along with basic\
                    metadata about the current configuration")
    dbsize_parser.add_argument('size_of', default=[], nargs='*', help="database, table, index, tablespace")
    dbsize_parser.add_argument('--bytes',action='store_true',help="Returns dbsize in bytes")
    dbsize_parser.add_argument('--json',action='store_true',help="Output JSON results of dbsizes")
    # Check
    check_parser = subparser.add_parser('check', help='Verify EPMT Installation',
        description="Check will verify basic epmt configuration and functionality.")
    # Delete
    delete_parser = subparser.add_parser('delete', help='Delete jobs from the database',
        description="Deletes jobs from the database.")
    delete_parser.add_argument('epmt_cmd_args', nargs='*', help="List of jobs to delete")
    # List
    list_parser = subparser.add_parser('list', help='Display all jobs in the database',
        description="Display all jobs in the database")
    list_parser.add_argument('epmt_cmd_args', nargs='*', help="A list of jobs to search for")
    # Notebook
    notebook_parser = subparser.add_parser('notebook', help="Start iPython Notebook environment",
                                           description="Perform programmatic, interactive analyses of EPMT data in iPython")
    notebook_parser.add_argument('epmt_cmd_args', nargs='*',
                                 help="Arguments to ipython notebook, first one **must** be preceded with double dash followed by a space, i.e. epmt notebook -- --ip 0.0.0.0 --allow-root, see epmt notebook -- --help for more info")
    # experiment explore (mostly GFDL-specific)
    exp_explore_parser = subparser.add_parser('explore', help="Explore a particular experiment, looking for outliers", description="Drilldown into an experiment using job tags")
    exp_explore_parser.add_argument('epmt_cmd_args', help="Experiment name (matched against the 'exp_name' in job tags)")
    exp_explore_parser.add_argument('--metric', help="metric to measure (default: duration)")
    exp_explore_parser.add_argument('--limit', type=int, help="number of components to show (default: 10)")

# Dummy Help for ./epmt help
    help_parser = subparser.add_parser('help', help="Display this help with extended configuration information")

    # Print help without dump config
    if len(argv) == 1:
        parser.epilog=''
        parser.print_help()
        exit(1)
    args = parser.parse_args()
    #print(vars(args))

    # Print help if epmt help is called
    if args.command == 'help':
        parser.print_help()
        exit(0)

    # Print help if 
    if args.command == None:
        parser.print_help()
        exit(0)

    retval = epmt_entrypoint(args)
    # trap any unhandled exceptions
    # try:
    #     retval = epmt_entrypoint(args)
    # except Exception as e:
    #     retval = -1
    #     # print('An exception occured (stack backtrace follows below): ', file=stderr)
    #     # from logging import getLogger
    #     # logger = getLogger(__name__)
    #     # logger.error(e, exc_info=True)
    #     print('\n\nAn exception occurred; the full stack backtrace is reproduced below: ', file=stderr)
    #     # sometimes even traceback gives unicode exceptions, so best to be safe
    #     # try:
    #     import traceback
    #     print('-'*60, file=stderr)
    #     traceback.print_exc(file=stderr)
    #     print('-'*60, file=stderr)
    #     # except:
    #     #     pass
    exit(retval)

else:
    print("ERROR: This module cannot be imported.",file=stderr)
    exit(1)
